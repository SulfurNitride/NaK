"""
Launch Script Generator
Creates .sh scripts that launch MO2/Vortex with Proton-GE
"""

import os
from pathlib import Path
from typing import Optional
from src.utils.logger import get_logger
from src.utils.steam_utils import SteamUtils


class LaunchScriptGenerator:
    """Generates launch scripts for mod managers"""

    def __init__(self):
        self.logger = get_logger(__name__)
        self.steam_utils = SteamUtils()

    def generate_mo2_launch_script(
        self,
        prefix_path: Path,
        mo2_exe_wine_path: str,
        instance_name: str,
        proton_ge_path: Optional[Path] = None
    ) -> Path:
        """
        Generate a launch script for MO2

        Args:
            prefix_path: Path to the Wine prefix (e.g., ~/NaK/Prefixes/mo2_skyrim_se_default/pfx)
            mo2_exe_wine_path: Wine path to ModOrganizer.exe (e.g., Z:\\path\\to\\MO2\\ModOrganizer.exe)
            instance_name: Display name for this instance
            proton_ge_path: Path to specific Proton-GE version (defaults to ~/NaK/ProtonGE/active)

        Returns:
            Path to the generated .sh script
        """
        try:
            # Determine Proton-GE path
            if proton_ge_path is None:
                proton_ge_path = Path.home() / "NaK" / "ProtonGE" / "active"

            # Script will be placed in the parent directory of pfx
            script_dir = prefix_path.parent
            script_path = script_dir / "launch_mo2.sh"

            # Convert paths to absolute strings
            # Important: Don't resolve proton_ge_path to preserve the /active symlink
            prefix_path_abs = str(prefix_path.resolve())
            proton_ge_abs = str(proton_ge_path)  # Keep as symlink, don't resolve
            compat_data_path = str(script_dir.resolve())

            # Detect Steam path using existing utilities
            try:
                steam_path = self.steam_utils.get_steam_root()
                # Detect if this is Flatpak Steam
                is_flatpak_steam = "com.valvesoftware.Steam" in steam_path
                self.logger.info(f"Detected Steam path: {steam_path}")
                self.logger.info(f"Steam Type: {'Flatpak' if is_flatpak_steam else 'Native'}")
            except Exception as e:
                self.logger.warning(f"Failed to detect Steam path: {e}, using /tmp")
                steam_path = "/tmp"
                is_flatpak_steam = False

            script_content = f'''#!/bin/bash
# NaK Launch Script for Mod Organizer 2
# Instance: {instance_name}
# Generated by NaK Linux Modding Helper

# Paths
PROTON_GE="{proton_ge_abs}"
PREFIX="{prefix_path_abs}"
COMPAT_DATA="{compat_data_path}"
MO2_EXE="{mo2_exe_wine_path}"
STEAM_PATH="{steam_path}"
IS_FLATPAK_STEAM={"true" if is_flatpak_steam else "false"}

# Check if Proton-GE exists
if [ ! -f "$PROTON_GE/proton" ]; then
    zenity --error --text="Proton-GE not found at $PROTON_GE\\n\\nPlease install Proton-GE using the Proton-GE Manager in NaK." --title="NaK - Error" 2>/dev/null || \\
    echo "ERROR: Proton-GE not found at $PROTON_GE"
    exit 1
fi

# Check if Steam is running (required for games with Steam DRM)
if ! pgrep -x "steam" > /dev/null && ! pgrep -x "steamwebhelper" > /dev/null; then
    echo "WARNING: Steam is not running!"
    echo "Starting Steam in the background..."
    echo "NOTE: Steam is required for games with Steam DRM to work properly."

    # Start Steam based on installation type
    if [ "$IS_FLATPAK_STEAM" = "true" ]; then
        echo "Detected Flatpak Steam, using flatpak command..."
        nohup flatpak run com.valvesoftware.Steam -silent > /dev/null 2>&1 &
    else
        echo "Detected native Steam, using steam command..."
        nohup steam -silent > /dev/null 2>&1 &
    fi

    # Wait a moment for Steam to start
    echo "Waiting 5 seconds for Steam to initialize..."
    sleep 5
fi

# Set environment variables for Proton
export WINEPREFIX="$PREFIX"
export STEAM_COMPAT_DATA_PATH="$COMPAT_DATA"
export STEAM_COMPAT_CLIENT_INSTALL_PATH="$STEAM_PATH"

# Optional: Enable Wine debug output (comment out for production)
# export WINEDEBUG=+all

# Launch MO2 with Proton-GE
echo "Launching Mod Organizer 2..."
echo "Instance: {instance_name}"
echo "Proton-GE: $PROTON_GE"
echo "Prefix: $PREFIX"
echo "Steam Path: $STEAM_PATH"

"$PROTON_GE/proton" run "$MO2_EXE" "$@"
'''

            # Write script
            script_path.write_text(script_content)

            # Make executable
            script_path.chmod(0o755)

            self.logger.info(f"Generated MO2 launch script: {script_path}")
            return script_path

        except Exception as e:
            self.logger.error(f"Failed to generate MO2 launch script: {e}")
            raise

    def generate_vortex_launch_script(
        self,
        prefix_path: Path,
        vortex_exe_wine_path: str,
        instance_name: str,
        proton_ge_path: Optional[Path] = None
    ) -> Path:
        """
        Generate a launch script for Vortex

        Args:
            prefix_path: Path to the Wine prefix (e.g., ~/NaK/Prefixes/vortex_cyberpunk_main/pfx)
            vortex_exe_wine_path: Wine path to Vortex.exe (e.g., Z:\\path\\to\\Vortex\\Vortex.exe)
            instance_name: Display name for this instance
            proton_ge_path: Path to specific Proton-GE version (defaults to ~/NaK/ProtonGE/active)

        Returns:
            Path to the generated .sh script
        """
        try:
            # Determine Proton-GE path
            if proton_ge_path is None:
                proton_ge_path = Path.home() / "NaK" / "ProtonGE" / "active"

            # Script will be placed in the parent directory of pfx
            script_dir = prefix_path.parent
            script_path = script_dir / "launch_vortex.sh"

            # Convert paths to absolute strings
            # Important: Don't resolve proton_ge_path to preserve the /active symlink
            prefix_path_abs = str(prefix_path.resolve())
            proton_ge_abs = str(proton_ge_path)  # Keep as symlink, don't resolve
            compat_data_path = str(script_dir.resolve())

            # Detect Steam path using existing utilities
            try:
                steam_path = self.steam_utils.get_steam_root()
                # Detect if this is Flatpak Steam
                is_flatpak_steam = "com.valvesoftware.Steam" in steam_path
                self.logger.info(f"Detected Steam path: {steam_path}")
                self.logger.info(f"Steam Type: {'Flatpak' if is_flatpak_steam else 'Native'}")
            except Exception as e:
                self.logger.warning(f"Failed to detect Steam path: {e}, using /tmp")
                steam_path = "/tmp"
                is_flatpak_steam = False

            script_content = f'''#!/bin/bash
# NaK Launch Script for Vortex
# Instance: {instance_name}
# Generated by NaK Linux Modding Helper

# Paths
PROTON_GE="{proton_ge_abs}"
PREFIX="{prefix_path_abs}"
COMPAT_DATA="{compat_data_path}"
VORTEX_EXE="{vortex_exe_wine_path}"
STEAM_PATH="{steam_path}"
IS_FLATPAK_STEAM={"true" if is_flatpak_steam else "false"}

# Check if Proton-GE exists
if [ ! -f "$PROTON_GE/proton" ]; then
    zenity --error --text="Proton-GE not found at $PROTON_GE\\n\\nPlease install Proton-GE using the Proton-GE Manager in NaK." --title="NaK - Error" 2>/dev/null || \\
    echo "ERROR: Proton-GE not found at $PROTON_GE"
    exit 1
fi

# Check if Steam is running (required for games with Steam DRM)
if ! pgrep -x "steam" > /dev/null && ! pgrep -x "steamwebhelper" > /dev/null; then
    echo "WARNING: Steam is not running!"
    echo "Starting Steam in the background..."
    echo "NOTE: Steam is required for games with Steam DRM to work properly."

    # Start Steam based on installation type
    if [ "$IS_FLATPAK_STEAM" = "true" ]; then
        echo "Detected Flatpak Steam, using flatpak command..."
        nohup flatpak run com.valvesoftware.Steam -silent > /dev/null 2>&1 &
    else
        echo "Detected native Steam, using steam command..."
        nohup steam -silent > /dev/null 2>&1 &
    fi

    # Wait a moment for Steam to start
    echo "Waiting 5 seconds for Steam to initialize..."
    sleep 5
fi

# Set environment variables for Proton
export WINEPREFIX="$PREFIX"
export STEAM_COMPAT_DATA_PATH="$COMPAT_DATA"
export STEAM_COMPAT_CLIENT_INSTALL_PATH="$STEAM_PATH"

# Optional: Enable Wine debug output (comment out for production)
# export WINEDEBUG=+all

# Launch Vortex with Proton-GE
echo "Launching Vortex..."
echo "Instance: {instance_name}"
echo "Proton-GE: $PROTON_GE"
echo "Prefix: $PREFIX"
echo "Steam Path: $STEAM_PATH"

"$PROTON_GE/proton" run "$VORTEX_EXE" "$@"
'''

            # Write script
            script_path.write_text(script_content)

            # Make executable
            script_path.chmod(0o755)

            self.logger.info(f"Generated Vortex launch script: {script_path}")
            return script_path

        except Exception as e:
            self.logger.error(f"Failed to generate Vortex launch script: {e}")
            raise

    def create_symlink(
        self,
        script_path: Path,
        target_dir: Path,
        link_name: str = "Open MO2"
    ) -> Path:
        """
        Create a symlink to the launch script in the user's installation directory

        Args:
            script_path: Path to the .sh launch script
            target_dir: Directory where symlink should be created (e.g., MO2 installation dir)
            link_name: Name for the symlink (default: "Open MO2")

        Returns:
            Path to the created symlink
        """
        try:
            symlink_path = target_dir / link_name

            # Remove existing symlink if it exists
            if symlink_path.exists() or symlink_path.is_symlink():
                symlink_path.unlink()

            # Create symlink
            symlink_path.symlink_to(script_path)

            # Make symlink executable (though this is usually not needed for symlinks)
            try:
                symlink_path.chmod(0o755)
            except (OSError, NotImplementedError) as e:
                # Ignore errors, as symlinks may not support chmod on all systems
                self.logger.debug(f"Could not chmod symlink: {e}")

            self.logger.info(f"Created symlink: {symlink_path} -> {script_path}")
            return symlink_path

        except Exception as e:
            self.logger.error(f"Failed to create symlink: {e}")
            raise

    def generate_prefix_name(
        self,
        manager_type: str,
        game_name: str,
        instance_name: str = "default"
    ) -> str:
        """
        Generate a safe, unique prefix name

        Args:
            manager_type: "mo2" or "vortex"
            game_name: Name of the game
            instance_name: Instance identifier

        Returns:
            Safe prefix name (e.g., "mo2_skyrim_se_default")
        """
        import re

        # Sanitize inputs: remove special characters, convert to lowercase
        def sanitize(text: str) -> str:
            # Remove special characters, keep only alphanumeric and spaces
            text = re.sub(r'[^a-zA-Z0-9\s]', '', text)
            # Replace spaces with underscores
            text = text.replace(' ', '_')
            # Convert to lowercase
            text = text.lower()
            # Remove multiple underscores
            text = re.sub(r'_+', '_', text)
            # Strip underscores from ends
            text = text.strip('_')
            return text

        manager = sanitize(manager_type)
        game = sanitize(game_name)
        instance = sanitize(instance_name)

        # Construct prefix name
        prefix_name = f"{manager}_{game}_{instance}"

        return prefix_name

    def check_prefix_name_collision(self, prefix_name: str) -> str:
        """
        Check if a prefix name already exists and generate a unique one if needed

        Args:
            prefix_name: Proposed prefix name

        Returns:
            Unique prefix name (may have _2, _3, etc. appended)
        """
        nak_prefixes_dir = Path.home() / "NaK" / "Prefixes"
        nak_prefixes_dir.mkdir(parents=True, exist_ok=True)

        # Check if name already exists
        original_name = prefix_name
        counter = 2

        while (nak_prefixes_dir / prefix_name).exists():
            prefix_name = f"{original_name}_{counter}"
            counter += 1
            self.logger.debug(f"Prefix name collision detected, trying: {prefix_name}")

        return prefix_name

    def generate_kill_prefix_script(
        self,
        prefix_path: Path,
        instance_name: str,
        proton_ge_path: Optional[Path] = None
    ) -> Path:
        """
        Generate a script to kill the wineserver for this prefix

        Args:
            prefix_path: Path to the Wine prefix (e.g., ~/NaK/Prefixes/mo2_skyrim_se_default/pfx)
            instance_name: Display name for this instance
            proton_ge_path: Path to specific Proton-GE version (defaults to ~/NaK/ProtonGE/active)

        Returns:
            Path to the generated kill script
        """
        try:
            # Determine Proton-GE path
            if proton_ge_path is None:
                proton_ge_path = Path.home() / "NaK" / "ProtonGE" / "active"

            # Script will be placed in the parent directory of pfx
            script_dir = prefix_path.parent
            script_path = script_dir / "kill_prefix.sh"

            # Convert paths to absolute strings
            prefix_path_abs = str(prefix_path.resolve())
            proton_ge_abs = str(proton_ge_path)

            script_content = f'''#!/bin/bash
# NaK Kill Prefix Script
# Instance: {instance_name}
# Generated by NaK Linux Modding Helper
#
# This script kills the wineserver for this prefix, which will:
# - Close all Wine processes running in this prefix
# - Free up system resources
# - Allow you to cleanly restart the prefix

PREFIX="{prefix_path_abs}"
PROTON_GE="{proton_ge_abs}"
WINESERVER="$PROTON_GE/files/bin/wineserver"

echo "=================================================="
echo "Killing Wine processes for: {instance_name}"
echo "Prefix: $PREFIX"
echo "=================================================="

# Check if wineserver exists
if [ ! -f "$WINESERVER" ]; then
    echo "ERROR: wineserver not found at $WINESERVER"
    echo "Using system wineserver instead..."
    WINESERVER="wineserver"
fi

# Kill the wineserver for this specific prefix
export WINEPREFIX="$PREFIX"

echo "Running: $WINESERVER -k"
"$WINESERVER" -k

if [ $? -eq 0 ]; then
    echo ""
    echo "✓ Successfully killed all Wine processes in this prefix"
    echo "  You can now safely restart {instance_name}"
else
    echo ""
    echo "⚠ wineserver command completed (no processes may have been running)"
fi

echo "=================================================="
'''

            # Write script
            script_path.write_text(script_content)

            # Make executable
            script_path.chmod(0o755)

            self.logger.info(f"Generated kill prefix script: {script_path}")
            return script_path

        except Exception as e:
            self.logger.error(f"Failed to generate kill prefix script: {e}")
            raise

    def generate_fix_game_registry_script(
        self,
        prefix_path: Path,
        instance_name: str,
        proton_ge_path: Optional[Path] = None
    ) -> Path:
        """
        Generate a script to fix game registry keys for Bethesda games

        This script:
        1. Shows a list of supported Bethesda games
        2. Asks user to select their game
        3. Asks for the Linux game installation path
        4. Converts Linux path to Wine path (Z:\...)
        5. Applies registry fix to the prefix

        Args:
            prefix_path: Path to the Wine prefix (e.g., ~/NaK/Prefixes/mo2_skyrim_se_default/pfx)
            instance_name: Display name for this instance
            proton_ge_path: Path to specific Proton-GE version (defaults to ~/NaK/ProtonGE/active)

        Returns:
            Path to the generated fix_game_registry.sh script
        """
        try:
            # Determine Proton-GE path
            if proton_ge_path is None:
                proton_ge_path = Path.home() / "NaK" / "ProtonGE" / "active"

            # Script will be placed in the parent directory of pfx
            script_dir = prefix_path.parent
            script_path = script_dir / "game_registry_fix.sh"

            # Convert paths to absolute strings
            prefix_path_abs = str(prefix_path.resolve())
            proton_ge_abs = str(proton_ge_path)

            script_content = f'''#!/bin/bash
# NaK Game Registry Fixer
# Instance: {instance_name}
# Generated by NaK Linux Modding Helper
#
# This script fixes the game installation path in the Windows registry
# so that mods and tools can find your game correctly.

PREFIX="{prefix_path_abs}"
PROTON_GE="{proton_ge_abs}"
REG="$PROTON_GE/files/bin/wine64 reg"

echo "=================================================="
echo "NaK Game Registry Fixer"
echo "Instance: {instance_name}"
echo "=================================================="
echo ""

# Check if reg.exe exists
if [ ! -f "$PROTON_GE/files/bin/wine64" ]; then
    echo "ERROR: wine64 not found at $PROTON_GE/files/bin/wine64"
    echo "Please ensure Proton-GE is properly installed."
    exit 1
fi

# Game registry configurations
# Format: "Game Name|Registry Path|Value Name"
declare -a GAMES=(
    "Enderal|Software\\\\SureAI\\\\Enderal|Install_Path"
    "Fallout 3|Software\\\\Bethesda Softworks\\\\Fallout3|Installed Path"
    "Fallout 4|Software\\\\Bethesda Softworks\\\\Fallout4|Installed Path"
    "Fallout 4 VR|Software\\\\Bethesda Softworks\\\\Fallout 4 VR|Installed Path"
    "Fallout New Vegas|Software\\\\Bethesda Softworks\\\\FalloutNV|Installed Path"
    "Morrowind|Software\\\\Bethesda Softworks\\\\Morrowind|Installed Path"
    "Oblivion|Software\\\\Bethesda Softworks\\\\Oblivion|Installed Path"
    "Skyrim|Software\\\\Bethesda Softworks\\\\Skyrim|Installed Path"
    "Skyrim Special Edition|Software\\\\Bethesda Softworks\\\\Skyrim Special Edition|Installed Path"
    "Skyrim VR|Software\\\\Bethesda Softworks\\\\Skyrim VR|Installed Path"
)

echo "Which Bethesda game are you modding?"
echo ""
for i in "${{!GAMES[@]}}"; do
    game_name=$(echo "${{GAMES[$i]}}" | cut -d'|' -f1)
    echo "  $((i+1)). $game_name"
done
echo ""
read -p "Enter number (1-${{#GAMES[@]}}): " choice

# Validate input
if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt "${{#GAMES[@]}}" ]; then
    echo "ERROR: Invalid selection"
    exit 1
fi

# Get selected game info
selected_game="${{GAMES[$((choice-1))]}}"
GAME_NAME=$(echo "$selected_game" | cut -d'|' -f1)
REG_PATH=$(echo "$selected_game" | cut -d'|' -f2)
VALUE_NAME=$(echo "$selected_game" | cut -d'|' -f3)

echo ""
echo "Selected: $GAME_NAME"
echo ""

# Ask for game installation path (with retry loop)
while true; do
    echo "Where is $GAME_NAME installed?"
    echo "Enter the LINUX path (e.g., /home/user/.steam/steam/steamapps/common/Skyrim Special Edition)"
    echo ""
    read -r -p "Game path: " GAME_PATH_LINUX

    # Validate path exists
    if [ -d "$GAME_PATH_LINUX" ]; then
        # Path is valid, continue
        break
    else
        echo ""
        echo "WARNING: Directory does not exist: $GAME_PATH_LINUX"
        read -r -p "Try again? (y/n): " retry_choice
        if [ "$retry_choice" != "y" ] && [ "$retry_choice" != "Y" ]; then
            echo "Cancelled."
            exit 1
        fi
        echo ""
    fi
done

# Convert Linux path to Wine path (Z:\\...)
# Replace forward slashes with backslashes and add Z: prefix
WINE_PATH="Z:${{GAME_PATH_LINUX//\\//\\\\\\\\}}"

echo ""
echo "=================================================="
echo "Registry Fix Details"
echo "=================================================="
echo "Game: $GAME_NAME"
echo "Linux Path: $GAME_PATH_LINUX"
echo "Wine Path: $WINE_PATH"
echo "Registry Key: HKLM\\\\$REG_PATH"
echo "Value Name: $VALUE_NAME"
echo "=================================================="
echo ""
read -p "Apply this registry fix? (y/n): " confirm

if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
    echo "Cancelled."
    exit 1
fi

# Set WINEPREFIX
export WINEPREFIX="$PREFIX"

echo ""
echo "Applying registry fix..."
echo ""

# Function to set registry value
set_registry() {{
    local reg_key="$1"
    local reg_flag="$2"

    echo "Setting: $reg_key ($reg_flag)"
    $REG add "HKLM\\\\$reg_key" /v "$VALUE_NAME" /d "$WINE_PATH" /f $reg_flag

    if [ $? -eq 0 ]; then
        echo "  ✓ Success"
        return 0
    else
        echo "  ✗ Failed"
        return 1
    fi
}}

# Apply registry fix to both 32-bit and 64-bit views
success_count=0

# 32-bit registry view
set_registry "$REG_PATH" "/reg:32"
[ $? -eq 0 ] && ((success_count++))

# 64-bit registry view (Wow6432Node)
WOW64_PATH=$(echo "$REG_PATH" | sed 's|^Software\\\\|SOFTWARE\\\\\\\\Wow6432Node\\\\\\\\|')
set_registry "$WOW64_PATH" "/reg:64"
[ $? -eq 0 ] && ((success_count++))

echo ""
echo "=================================================="
if [ $success_count -eq 2 ]; then
    echo "✓ Registry fix applied successfully!"
    echo ""
    echo "The game installation path has been set in the registry."
    echo "Your mods and tools should now be able to find the game."
elif [ $success_count -gt 0 ]; then
    echo "⚠ Registry fix partially applied ($success_count/2 succeeded)"
    echo ""
    echo "Some registry entries were set, but there were errors."
    echo "Your setup may still work, but check for any issues."
else
    echo "✗ Registry fix failed"
    echo ""
    echo "Could not set registry values. Check the error messages above."
fi
echo "=================================================="

# Offer to verify the registry
echo ""
read -p "Would you like to verify the registry values? (y/n): " verify_choice

if [ "$verify_choice" == "y" ] || [ "$verify_choice" == "Y" ]; then
    echo ""
    echo "Querying registry..."
    echo ""
    echo "32-bit view:"
    $REG query "HKLM\\\\$REG_PATH" /v "$VALUE_NAME" /reg:32
    echo ""
    echo "64-bit view (Wow6432Node):"
    $REG query "HKLM\\\\$WOW64_PATH" /v "$VALUE_NAME" /reg:64
fi

echo ""
echo "Done!"
'''

            # Write script
            script_path.write_text(script_content)

            # Make executable
            script_path.chmod(0o755)

            self.logger.info(f"Generated fix game registry script: {script_path}")
            return script_path

        except Exception as e:
            self.logger.error(f"Failed to generate fix game registry script: {e}")
            raise
